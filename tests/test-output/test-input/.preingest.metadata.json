[
    {
        "cft.dataset.db:ident": [
            "2023c7c6-0885-3bae-8889-dea16773281c"
        ], 
        "cft.dataset:samples": null, 
        "cft.dataset:outdir": "output/test-input", 
        "cft.dataset:id": "test-input-2018.08.15", 
        "cft.dataset:build": {
            "cft.build:diff": "diff --git a/.sconsign.dblite b/.sconsign.dblite\nindex b6ac0cc..5b33a3b 100644\nBinary files a/.sconsign.dblite and b/.sconsign.dblite differ\ndiff --git a/SConstruct b/SConstruct\nindex 0f06c1a..f7fddb2 100644\n--- a/SConstruct\n+++ b/SConstruct\n@@ -401,6 +401,7 @@ def add_cluster_analysis(w):\n                     ' --max-sequences 10000' +\n                     ' --paths-relative-to ' + dataset_outdir(c) +\n                     ' --namespace cft.cluster' +\n+                    ' --inferred-naive-name ' + options['inferred_naive_name'] +\n                   ((\" --always-include \" + ','.join(c['sample']['seeds'])) if c['sample'].get('seeds') else '') +\n                    (' --partition {}'.format(c['partition']['step']) if c.get('seed') else '') +\n                    (' --cluster {}'.format(c['cluster']['sorted_index']) if not c.get('seed') else '') +\n@@ -466,7 +467,7 @@ def add_cluster_analysis(w):\n             \"prune.py -n \" + str(recon['prune_count'])\n                 + ((\" --always-include \" + ','.join(c['sample']['seeds'])) if c['sample'].get('seeds') else '')\n                 + \" --strategy \" + recon['prune_strategy']\n-                + \" --naive naive\"\n+                + \" --naive %s\" % options['inferred_naive_name']\n                 + (\" --seed \" + c['seed']['id'] if 'seed' in c else '')\n                 + \" $SOURCE $TARGET\")\n \n@@ -516,7 +517,7 @@ def add_cluster_analysis(w):\n         return env.Command(\n             [path.join(outdir, x) for x in ('pruned.phy', 'seqname_mapping.csv')],\n             c['pruned_seqs'],\n-            'make_phylip.py $SOURCE $TARGETS --dont-rename naive')\n+            'make_phylip.py $SOURCE $TARGETS --dont-rename ' + options['inferred_naive_name'])\n \n \n     @w.add_target()\n@@ -540,7 +541,7 @@ def add_cluster_analysis(w):\n             config = env.Command(\n                 path.join(outdir, asr_prog + \".cfg\"),\n                 c['phy'],\n-                'python bin/mkconfig.py $SOURCE ' + asr_prog + ' > $TARGET')\n+                'python bin/mkconfig.py $SOURCE ' + asr_prog + ' --inferred-naive-name ' + options['inferred_naive_name'] + '> $TARGET')\n             phylip_out = env.SRun(\n                 path.join(outdir, \"outfile\"),\n                 config,\n@@ -560,6 +561,7 @@ def add_cluster_analysis(w):\n                         + (\" --seed \" + c['seed']['id'] if 'seed' in c else '')\n                         + \" --outdir \" + outdir\n                         + \" --basename \" + basename\n+                        + \" --inferred-naive-name \" + options['inferred_naive_name']\n                         + \" --seqname-mapping $SOURCES\")\n             asr_tree, asr_tree_svg, asr_seqs = tgt\n             # manually depnd on this because the script isn't in first position\n@@ -572,11 +574,11 @@ def add_cluster_analysis(w):\n                 c['pruned_seqs'],\n                 # Question should use -T for threads? how many?\n                 # Don't know if the reroot will really do what we want here\n-                'raxml.py --rapid-bootstrap 30 -x 3243 -o naive $SOURCE $TARGET')\n+                'raxml.py --rapid-bootstrap 30 -x 3243 -o %s $SOURCE $TARGET' % options['inferred_naive_name'])\n             asr_tree_svg = env.Command(\n                 path.join(outdir, 'asr.svg'),\n                 [asr_supports_tree, c['seqmeta']],\n-                'xvfb-run -a bin/plot_tree.py $SOURCES $TARGET --supports'\n+                'xvfb-run -a bin/plot_tree.py $SOURCES $TARGET --supports --inferred-naive-name ' + options['inferred_naive_name']\n                     + (' --seed ' + c['seed'] if 'seed' in c else ''))\n             asr_tree = env.Command(\n                 path.join(outdir, 'asr.nwk'),\ndiff --git a/bin/mkconfig.py b/bin/mkconfig.py\nindex 24c590c..2a8918e 100755\n--- a/bin/mkconfig.py\n+++ b/bin/mkconfig.py\n@@ -47,13 +47,12 @@ import os\n import argparse\n from warnings import warn\n \n-def extract_naive(file):\n+def extract_naive(file, inferred_naive_name):\n     with open( file, 'r' ) as fh:\n-        for lineno,line in enumerate(fh):\n-            if re.match(\".*naive.*\", line):\n+        for lineno, line in enumerate(fh):\n+            if len(line.split()) > 0 and line.split()[0] == inferred_naive_name:\n                 return lineno\n \n-\n def main():\n \n     def existing_file(fname):\n@@ -68,16 +67,17 @@ def main():\n \n     parser.add_argument('phylip', nargs=1, help='PHYLIP input', type=existing_file)\n     parser.add_argument('treeprog', help='dnaml or dnapars', type=str)\n-    a = parser.parse_args()\n+    parser.add_argument('--inferred-naive-name', required=True)\n+    args = parser.parse_args()\n \n-    naive = extract_naive(a.phylip[0])\n-    print(\"{}\".format(os.path.basename(a.phylip[0])))\t\t# phylip input file\n+    naive = extract_naive(args.phylip[0], args.inferred_naive_name)\n+    print(\"{}\".format(os.path.basename(args.phylip[0])))\t\t# phylip input file\n     if naive:\n         print(\"O\")\t\t\t\t\t\t# Outgroup root\n         print(\"{}\".format(naive))\t\t# naive index in phylip\n     else:\n         warn(\"No na\u00efve sequence found!\")\n-    if a.treeprog == 'dnapars':\n+    if args.treeprog == 'dnapars':\n         print('S')\n         print('Y')\n         print('J')\n@@ -87,14 +87,14 @@ def main():\n         print('5')\n         print('.')\n         print('Y')\n-    elif a.treeprog == 'dnaml':\n+    elif args.treeprog == 'dnaml':\n         print(\"R\") # gamma\n         print(\"5\")                                         # Reconstruct hypothetical seq\n         print(\"Y\")                                         # accept these\n         print(\"1.41421356237\") # CV = sqrt(2) (alpha = .5)\n         print(\"4\") # 4 catagories\n     else:\n-        raise RuntimeError('treeprog='+a.treeprog+' is not \"dnaml\" or \"dnapars\"')\n+        raise RuntimeError('treeprog=' + args.treeprog + ' is not \"dnaml\" or \"dnapars\"')\n \n \n if __name__ == \"__main__\":\ndiff --git a/bin/plot_tree.py b/bin/plot_tree.py\nindex 054b80d..8ba62e2 100755\n--- a/bin/plot_tree.py\n+++ b/bin/plot_tree.py\n@@ -11,18 +11,21 @@ import colorbrewer\n def find_node(tree, pattern):\n     regex = re.compile(pattern).search\n     nodes =  [ node for node in tree.traverse() for m in [regex(node.name)] if m]\n+# ----------------------------------------------------------------------------------------\n     if not nodes:\n         warnings.warn(\"Cannot find matching node; looking for name matching '{}'\".format(pattern))\n         return\n+# ----------------------------------------------------------------------------------------\n     else:\n         if len(nodes) > 1:\n             warnings.warn(\"multiple nodes found; using first one.\\nfound: {}\".format([n.name for n in nodes]))\n         return nodes[0]\n \n \n-# reroot the tree on node matching regex pattern.\n-# Usually this is used to root on the naive germline sequence with a name matching 'naive'\n-def reroot_tree(tree, pattern='naive'):\n+# reroot the tree on node matching pattern.\n+# Usually this is used to root on the naive germline sequence\n+# NOTE duplicates fcn in process_asr.py\n+def reroot_tree(tree, pattern):\n     # find all nodes matching pattern\n     node = find_node(tree, pattern)\n     if tree != node:\n@@ -113,7 +116,7 @@ def leaf_style(node, seqmeta, tp_colors, highlight_node=None):\n     ete3.add_face_to_node(pie_node, node, column=0)\n \n \n-def render_tree(fname, tree, annotations, highlight_node, supports=False, support_cuttof=0.8):\n+def render_tree(fname, tree, annotations, highlight_node, inferred_naive_name, supports=False, support_cuttof=0.8):\n     \"render tree SVG\"\n     ts = ete3.TreeStyle()\n     ts.show_leaf_name = False\n@@ -148,8 +151,8 @@ def render_tree(fname, tree, annotations, highlight_node, supports=False, suppor\n     timepoint_legend(ts, tp_colors)\n     multiplicity_legend(ts)\n     # whether or not we had rerooted on naive before, we want to do so for the SVG tree\n-    if 'naive' not in tree.name:\n-        tree = reroot_tree(tree, 'naive')\n+    if inferred_naive_name not in tree.name:\n+        tree = reroot_tree(tree, inferred_naive_name)\n     ts.scale = 2300\n     tree.render(fname, tree_style=ts)\n \n@@ -180,6 +183,8 @@ def get_args():\n         help=\"Sequence metadata file for annotating mut_freqs\")\n     parser.add_argument('svg_out', help=\"output file\")\n     parser.add_argument(\n+        '--inferred-naive-name', type=str, required=True)\n+    parser.add_argument(\n         '--seed', type=str, help=\"id of leaf [default 'seed']\", default='seed')\n     return parser.parse_args()\n \n@@ -192,10 +197,10 @@ def main():\n     with open(args.tree) as fh:\n         tree = ete3.Tree(fh.read(), format=(0 if args.supports else 1))\n \n-    tree = reroot_tree(tree, 'naive')\n+    tree = reroot_tree(tree, args.inferred_naive_name)\n \n     # write newick file\n-    render_tree(args.svg_out, tree, args.seqmeta, args.seed, supports=args.supports)\n+    render_tree(args.svg_out, tree, args.seqmeta, args.seed, args.inferred_naive_name, supports=args.supports)\n \n \n if __name__ == '__main__':\ndiff --git a/bin/process_asr.py b/bin/process_asr.py\nindex 420772c..5b6defa 100755\n--- a/bin/process_asr.py\n+++ b/bin/process_asr.py\n@@ -77,7 +77,7 @@ def parse_seqdict(fh, mode='dnaml'):\n # parse the dnaml output file and return data strictures containing a\n # list biopython.SeqRecords and a dict containing adjacency\n # relationships and distances between nodes.\n-def parse_outfile(outfile, seqmeta, seqname_mapping=None):\n+def parse_outfile(outfile, seqmeta, inferred_naive_name, seqname_mapping=None):\n     '''parse phylip outfile'''\n     name_map = seqname_mapping or {seq_id[0:10]: seq_id for seq_id in seqmeta}\n     if len(name_map) != len(seqmeta) and not seqname_mapping:\n@@ -106,9 +106,9 @@ def parse_outfile(outfile, seqmeta, seqname_mapping=None):\n             else:\n                 raise RuntimeError(\"unrecognized phylip setion = {}\".format(sect))\n \n-    if 'naive' in bads:\n+    if inferred_naive_name in bads:\n         warn(\"Uh... naive in bad sequences?\")\n-        bads.remove('naive')\n+        bads.remove(inferred_naive_name)\n     if bads:\n         print(\"good sequences:\", sorted(goods))\n         print(\"bad sequences:\", sorted(bads))\n@@ -166,8 +166,9 @@ def find_node(tree, pattern):\n \n \n # reroot the tree on node matching regex pattern.\n-# Usually this is used to root on the naive germline sequence with name 'naive'\n-def reroot_tree(tree, pattern='naive'):\n+# Usually this is used to root on the naive germline sequence\n+# NOTE duplicates fcn in plot_tree.py\n+def reroot_tree(tree, pattern):\n     # find all nodes matching pattern\n     node = find_node(tree, pattern)\n     if tree != node:\n@@ -219,6 +220,8 @@ def get_args():\n     parser.add_argument(\n         '--basename', help=\"basename of output files.   [default 'basename(DNAML)']\")\n     parser.add_argument(\n+        '--inferred-naive-name', type=str, required=True)\n+    parser.add_argument(\n         '--seed', type=str, help=\"id of leaf [default 'seed']\", default='seed')\n     return parser.parse_args()\n \n@@ -230,7 +233,7 @@ def main():\n     basename = args.basename if args.basename else os.path.basename(args.phylip_outfile)\n     outbase = os.path.join(args.outdir, os.path.splitext(basename)[0])\n \n-    sequences, parents = parse_outfile(args.phylip_outfile, args.seqmeta, args.seqname_mapping)\n+    sequences, parents = parse_outfile(args.phylip_outfile, args.seqmeta, args.inferred_naive_name, args.seqname_mapping)\n \n     if not sequences or not parents:\n         raise RuntimeError(\"No sequences were available; are you sure this is a dnaml output file?\")\n@@ -241,13 +244,13 @@ def main():\n         SeqIO.write(sequences, fh, \"fasta\")\n \n     tree = build_tree(sequences, parents)\n-    tree = reroot_tree(tree, 'naive')\n+    tree = reroot_tree(tree, args.inferred_naive_name)\n \n     # write newick file\n     fname = outbase + '.nwk'\n     tree.write(format=1, format_root_node=True, outfile=fname)\n \n-    plot_tree.render_tree(outbase+'.svg', tree, args.seqmeta, args.seed)\n+    plot_tree.render_tree(outbase+'.svg', tree, args.seqmeta, args.seed, args.inferred_naive_name)\n \n \n if __name__ == \"__main__\":\ndiff --git a/bin/process_partis.py b/bin/process_partis.py\nindex f9e4dd0..2ff1c08 100755\n--- a/bin/process_partis.py\n+++ b/bin/process_partis.py\n@@ -132,7 +132,7 @@ def merge_upstream_seqmeta(partis_seqmeta, upstream_seqmeta):\n def downsample_sequences(args, sequences):\n     sequences = list(sequences)\n     if args.max_sequences:\n-        always_include = set(args.always_include + ['naive'])\n+        always_include = set(args.always_include + [args.inferred_naive_name])\n         always_include_seqs = filter(lambda x: x.get('unique_id') in always_include, sequences)\n         rest_seqs = filter(lambda x: x.get('unique_id') not in always_include, sequences)\n         # first take the always keep, then take as many as you can of the remaining seqs, in order of highest multiplicity\n@@ -156,7 +156,7 @@ def process_cluster(args, cluster_line, seed_id):\n     utils.add_implicit_info(args.glfo, cluster_line)\n \n     cluster_sequences = {\n-            'unique_id':             ['naive'] + cluster_line['unique_ids'],\n+            'unique_id':             [args.inferred_naive_name] + cluster_line['unique_ids'],\n             'seq': [cluster_line['naive_seq']] + seqs(args, cluster_line),\n             'is_seed':               ['False'] + [(unique_id == seed_id) for unique_id in cluster_line['unique_ids']],\n             'duplicates':               [None] + [':'.join(x) for x in cluster_line['duplicates']],\n@@ -391,6 +391,9 @@ def parse_args():\n     other_args.add_argument(\n         '--namespace',\n         help='namespace to be applied to cluster meta attr names')\n+    other_args.add_argument(\n+        '--inferred-naive-name',\n+        help='see scons option help')\n     # --indel-reversed-seqs\n     # --remove-mutated-invariants\n \ndiff --git a/bin/prune.py b/bin/prune.py\nindex f1f2e95..ad843d2 100755\n--- a/bin/prune.py\n+++ b/bin/prune.py\n@@ -145,7 +145,7 @@ def get_args():\n     parser.add_argument(\n         '--strategy', choices=[\"min_adcl\", \"seed_lineage\"], default=\"seed_lineage\")\n     parser.add_argument(\n-        '--naive', help='id of root [default \\'naive\\']', default='naive')\n+        '--naive', help='id of root', required=True)  # make it required so the default can be set/enforced in the SConstruct\n     parser.add_argument(\n         '--seed', help='id of leaf [default \\'seed\\']')\n     parser.add_argument(\ndiff --git a/site_scons/options.py b/site_scons/options.py\nindex 7f7661f..ef407b7 100644\n--- a/site_scons/options.py\n+++ b/site_scons/options.py\n@@ -53,6 +53,11 @@ Script.AddOption('--lazy-metadata',\n         time when debugging, or when only code in scripts has changed. If `--lazy-metadata` is used, it's best to run again\n         before using any of the output metadata.json files.\"\"\")\n \n+Script.AddOption('--inferred-naive-name',\n+        dest='inferred_naive_name',\n+        default='X-naive-X',  # needs to be fairly obscure so it doesn't conflict with any names in the input file\n+        help=\"\"\"What do we call the partis-inferred naive sequence when we inject it among the other (input) sequences.\"\"\")\n+\n \n def get_options(env):\n     # prefer realpath so that running latest vs explicit vN doesn't require rerun; also need for defaults below\n@@ -64,6 +69,7 @@ def get_options(env):\n         prune_strategies = env.GetOption('prune_strategies').split(':'),\n         dataset_tag = env.GetOption('dataset_tag') or ('test' if test_run else None),\n         always_build_metadata = not env.GetOption('lazy_metadata'),\n+        inferred_naive_name = env.GetOption('inferred_naive_name'),\n         outdir_base = env.GetOption('outdir'))\n \n \n", 
            "cft.build:software": [
                {
                    "cft.software:version": "1.66", 
                    "cft.software:name": "biopython", 
                    "cft.software:which": null
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "FastTree", 
                    "cft.software:which": "/home/dralph/bin/FastTree\n"
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "prank", 
                    "cft.software:which": "/usr/bin/prank\n"
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "dnaml", 
                    "cft.software:which": "/home/dralph/anaconda_ete/envs/cft/bin/dnaml\n"
                }, 
                {
                    "cft.software:version": "0.0.1", 
                    "cft.software:name": "tripl", 
                    "cft.software:which": null
                }, 
                {
                    "cft.software:version": "3.1.1", 
                    "cft.software:name": "ete3", 
                    "cft.software:which": null
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "rppr", 
                    "cft.software:which": "/home/dralph/bin/rppr\n"
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "scons", 
                    "cft.software:which": "/home/dralph/anaconda_ete/envs/cft/bin/scons\n"
                }, 
                {
                    "cft.software:version": "4.4.0", 
                    "cft.software:name": "dendropy", 
                    "cft.software:which": null
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "seqmagick", 
                    "cft.software:which": "/home/dralph/.local/bin/seqmagick\n"
                }, 
                {
                    "cft.software:version": null, 
                    "cft.software:name": "muscle", 
                    "cft.software:which": "/usr/bin/muscle\n"
                }
            ], 
            "cft.build:commit": "6387517fe3b0d522848852a84691282a8c3e52b9\n", 
            "cft.build:status": " M .sconsign.dblite\n M SConstruct\n M bin/mkconfig.py\n M bin/plot_tree.py\n M bin/process_asr.py\n M bin/process_partis.py\n M bin/prune.py\n M site_scons/options.py\n?? bcr-phylo.yaml\n?? init.sh\n?? output.bak/\n", 
            "cft.build:command": "/home/dralph/anaconda_ete/envs/cft/bin/scons", 
            "cft.build:user": "dralph", 
            "cft.build:id": "cft-build-2018-08-15-19:00:19", 
            "cft.build:workdir": "/home/dralph/work/cft", 
            "cft.build:time": "2018-08-15 19:00:19", 
            "tripl:type": "cft.build", 
            "db:ident": [
                "20680580-a0f8-11e8-8b0f-c52491d13ce2"
            ], 
            "cft.build.db:ident": [
                "20680580-a0f8-11e8-8b0f-c52491d13ce2"
            ]
        }, 
        "cft.dataset:label": "test-input", 
        "cft.dataset:metadata_snapshot": [
            {
                "tripl.file:sources": [
                    {
                        "tripl.file:path": "metadata.json"
                    }
                ], 
                "db:ident": [
                    "816d61eb-f1e7-3b7d-a026-614590cb42de"
                ], 
                "tripl.file:path": "2018-08-15-metadata.json"
            }
        ], 
        "tripl:type": "cft.dataset", 
        "db:ident": [
            "2023c7c6-0885-3bae-8889-dea16773281c"
        ]
    }
]